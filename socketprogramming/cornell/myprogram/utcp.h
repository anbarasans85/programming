#define MAX_MSG_LEN 4096

#define EMAXCONN 255 /* utcp error: exceeded max connections. */

/* The structure defines a few of the variables you would need in the header. You can add to this, any other you would need. */ 
typedef struct {
	unsigned int seqNo;
	unsigned int checkSum;
	unsigned int flags;
	unsigned int dataLen;  
} UTCPHeaderType;

#define MAX_DATA_LEN (MAX_MSG_LEN - sizeof(UTCPHeaderType))

typedef struct {
	UTCPHeaderType header;
	char data[MAX_DATA_LEN];
} UTCPPacketType;

typedef int connIdType;
typedef int bindIdType;

/* The following function gives the interface you are expected to support. Kindly define all other functions elsewhere. */

/* Initializer.
 */
void utcpInit ();

/* Finalizer for the entire program.
 */
void utcpQuit ();

/* Finalizer for each thread.
 */
void utcpThreadQuit ();

/* Called by server; non-blocking;
 * Binds a socket and listens to the specified port.
 * Returns a handle to this listener upon success and -1 upon failure.
 * The bind handle (int bindId) could just be the sockfd for simplicity.
 * You can ignore the bind handle if you only plan to support one connection at a time.
 */ 

bindIdType utcpBind (int port);

/* Called by client; blocking
 * Opens a reliable connection to the specifid address and port. 
 * The windowSize gives the maximum size of the receive window at this end.
 * Returns a handle for the connection upon success and -1 for failure.
 * The connection handle (int connId) could just be an index to the list of connections or the socketfd for convenience.
 * You can ignore the connection handle if you only plan to support one connection at a time.
 */ 

connIdType utcpConnect (char *ipAddr, int port, int windowSize);



/* Called by server; blocking;
 * Waits for a connection at the listner identfied by the bindId.
 * The windowSize gives the maximum size of the receive window at this end.
 * Returns a handle for the connection upon success and -1 for failure.
 * The connection handle could just be an index to the list of connections or the socketfd for convenience.
 * You can ignore the connection handle if you only plan to support one connection at a time.
 */ 

connIdType utcpAccept (bindIdType bindId, int windowSize); /* blocking. */


/* Called by server and client; non-blocking;
 * Closes the connection specified by the connId.
 * Returns 0 upon success and -1 upon failure.
 */ 

int utcpClose (connIdType connId);


/* Called by server and client;
 * Reliably sends the data specified. 
 * The dataLen gives the length of specified data.
 * Returns 0 upon success and -1 upon failure.
 * Note that this function needs to be non-blocking to support any interesting applications. In that case, return value need not reflect a successful send of the data but only absence of local errors.
 */ 

int utcpSend (connIdType connId, char *data, int dataLen);


/* Called by server and client; blocking;
 * Waits for data and receives data sent.  
 * The data array is where the recived data should be copied into.
 * The dataLen gives the maximum length of specified data buffer.
 * Returns number of bytes received upon success and -1 upon failure.
 */ 
int utcpRecv (connIdType connId, char *data, int dataLen);


/* ERRORs and Failure.
 * Upon a local failure or an error these functions return a value of -1.
 * In addition it is also recommended that you set the approproate error code.
 * for errors generated by utcp. 
 * See evilSend.c for an example on how to set error codes.
 * Define these errors in this file.
 */
